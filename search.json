[
  {
    "objectID": "projects/bigT_ros_control/index.html",
    "href": "projects/bigT_ros_control/index.html",
    "title": "Big T ROS Navigation and Control",
    "section": "",
    "text": "Open in Github\nThis post describes the control node implementation for a three-wheeled omni-wheeled holonomic robot to update motor direction and speed from incoming linear and angular velocities."
  },
  {
    "objectID": "projects/bigT_ros_control/index.html#build",
    "href": "projects/bigT_ros_control/index.html#build",
    "title": "Big T ROS Navigation and Control",
    "section": "Build",
    "text": "Build\nBig T is an autonomous three-wheeled omni-wheel holonomic robot with SLAM capabilities.\n\n\n\nBig T is mounted with both exterioceptive sensors such as a mouse sensor, LIDAR and Intel RealSense and proprioceptive sensors such as IMU and encoders to capture odometry signals to inform the control algorithm."
  },
  {
    "objectID": "projects/bigT_ros_control/index.html#mapping-modes",
    "href": "projects/bigT_ros_control/index.html#mapping-modes",
    "title": "Big T ROS Navigation and Control",
    "section": "Mapping Modes",
    "text": "Mapping Modes\nThere are two main mapping modes we can operate in with Big T.\n\nThe map of the environment is first created using Hector SLAM to simulataneously localise and map the environment and save the map. See here for ref. Hector SLAM is used in conjunction with an extended Kalman filter (EKF) to fuse wheel odometry with IMU to create an improved odometry estimate. This example below shows the robot performing autonomous SLAM to map the environment.\n\n\n\n\n\nWe can test localising the robot inside the saved map using AMCL (Adaptive Monte Carlo localisation) which estimates 2D position based on particle filter. The robot’s pose is represented as a distribution of particles, where each particle represents a possible pose of the robot. It takes as input a map, LIDAR scans, and transform messages, and outputs an estimated pose. See here for more details."
  },
  {
    "objectID": "projects/bigT_ros_control/index.html#architecture",
    "href": "projects/bigT_ros_control/index.html#architecture",
    "title": "Big T ROS Navigation and Control",
    "section": "Architecture",
    "text": "Architecture\nBig T can be run into two operative modes, high level block digrams are shown below:\n\nAutonomous Mode - this mode is often used for SLAM navigation.\n\n\n\n\n\nTele-operative Mode - this mode is often used for user-controlled navigation in a saved map and also for debugging purposes."
  },
  {
    "objectID": "projects/bigT_ros_control/index.html#control-algorithm",
    "href": "projects/bigT_ros_control/index.html#control-algorithm",
    "title": "Big T ROS Navigation and Control",
    "section": "Control Algorithm",
    "text": "Control Algorithm\nThe robot’s velocity commands are published on the cmd_vel topic from either theteleop_twist_keyboard node in teleop mode or move_base node in the ROS navigation stack when in SLAM node. The control node aims to translate directions in the global frame to the individual directions to each motor in three-wheeled omnidirectional robot configuration.\n\n1. Imports and Global Variables\nWe first import our initial C++ ROS headers and instantiate our global variables from the robot’s physical characteristics.\nWe include the following headers - [ros/ros.h] to include too headers necessary to use the most common public pieces of the ROS system. - geometry_msgs/Twist.h to publish linear and angular velocities to facilitate interoperability throughout the system. - geometry_msgs/Quaternion.h to publish orientation in quarternion form. - sensor_msgs/Imu.h to collect sensor data message type from the IMU. The IMU node razor_imu_9dof publishes messages to the \"imu\" topic in the ROS system to be used by motion and planning algorithms such as this robot_pose_ekf. - math.h to perform common mathmetical operations and transformations.\nWe then declare our ROS publishers motor_control_pub to publish the motor control signal to the wheels and imu_pub to publish and update the robot’s orientation.\n\n#include \"ros/ros.h\"\n#include \"geometry_msgs/Twist.h\"\n#include \"geometry_msgs/Quaternion.h\"\n#include \"sensor_msgs/Imu.h\"\n#include &lt;math.h&gt;\n\nfloat omega1, omega2, omega3; // angular velocities\nfloat r = 0.0525; // Wheel radius (105mm/2)\nfloat h = 0.18;   // Distance from the center of the body to the wheel (180mm)\n\nfloat v_x = 0;    // Global translation speed in x (m/s)\nfloat v_y = 0;    // Global translation speed in y (m/s)\nfloat omega_body = 0;  // Rotational speed of the body (rad/s)\nfloat theta = 3.1415;  // Orientation of the body (rad)\n\nros::Publisher motor_control_pub;\nros::Publisher imu_pub;\n\n\n\n\n2. Main Loop\nWe first set up the appropriate ROS publishers and subscribers, to enable ROS signal communication between incoming sensor and output motor nodes in the ROS ecosystem.\nThe main loop is as follows:\n\nInitialises the ROS system with the node name triangle_control.\nCreates ros::NodeHandle to interface with the ROS system.\nSets up publisher pub to publish motor control data on the motor_control_data topic.\nSets up imu_sub to receive IMU data on imu topic to process with imu_callback function. This allows us to explicitly publish the IMU orientation to an orientation topic.\nSets up imu_pub to receive velocity cmmmands on the cmd_vel topic and process with the cmd_vel_callback function. The cmd_vel topic is typically used to publish velocity commands published by the teleop_twist_keyboard node in teleop mode or move_base node in the ROS navigation stack when in SLAM node.\nEnters infinite event loop with ros::spin() to continuously process incoming messages on all topics to which the node is subscribed (eg. imu and cmd_vel), call the appropriate callback functions (eg. imu_callback and cmd_vel_callback) and publish messages to the advertised topics (eg. motor_control_data and orientation). It blocks the main thread and ensures the triangle_control runs for as long as the ROS system is active.\n\n\nint main(int argc, char **argv){\n\n\tros::init(argc, argv, \"triangle_control\");\n\n\tros::NodeHandle n;\n\n\tmotor_control_pub = n.advertise&lt;geometry_msgs::Twist&gt;(\"motor_control_data\", 1000);\n\n\tros::Subscriber imu_sub = n.subscribe(\"imu\", 1000, imu_callback);\n\n\timu_pub = n.advertise&lt;geometry_msgs::Quaternion&gt;(\"orientation\", 1000);\n\n\tros::Subscriber sub = n.subscribe(\"cmd_vel\", 1000, cmd_vel_callback);\n\n\tros::spin();\n\n\treturn 0;\n\n}\n\n\n\n3: Converting Sensor Input to Angular Velocities\nThe main callback function that updates the robot’s direction is cmd_vel_callback which is subscribed to the cmd_vel topic of a data type of geometry_msgs::Twist which expresses velocity in it’s angular and linear parts. This function translates the desired linear and angular velocities of the robot into individual wheel speeds, converts those speeds to PWM signals, and determines the direction for each wheel. It then publishes these control signals to the motor_control_pub topic to update the robot direction .\n\nvoid cmd_vel_callback(const geometry_msgs::Twist & msg){\n\t/*\n\t\tomega1\t...\trotation speed of motor 1\t(in rad/s)\n\t\tomega2\t...\trotation speed of motor 2\t(in rad/s)\n\t\tomega3\t...\trotation speed of motor 3\t(in rad/s)\n\t*/\n\tROS_INFO(\"Msg received\");\n\n\tgeometry_msgs::Twist out_msg;\n\tv_x = msg.linear.x;\n\tv_y = msg.linear.y;\n\tomega_body = msg.angular.z;\n\n\tomega1 = 1/r * (v_x * cosf(theta) + v_y * sinf(theta) + omega_body * h);\n\tomega2 = 1/r * (cosf(theta) * v_y/3 -  sinf(theta) * v_x/3 +  sqrt(3) * sinf(theta) * v_y/3 +  sqrt(3) * cosf(theta) * v_x /3 + omega_body * h);\n\tomega3 = 1/r * (-sqrt(3) * sinf(theta) * v_y/3 + cosf(theta) * v_y/3 -  sqrt(3)  * cosf(theta) * v_x/3 - sinf(theta) * v_x/3 + omega_body * h);\n\n\t// pwm signal\n\tout_msg.linear.x = omega2pwm(omega1); // convert from rad/s to pwm signal\n\tout_msg.linear.y = omega2pwm(omega2);\n\tout_msg.linear.z = omega2pwm(omega3);\n\n\t// motor direction\n\tout_msg.angular.x = sign(omega1); // set direction bit depending on the rotation speed\n\tout_msg.angular.y = sign(omega2);\n\tout_msg.angular.z = sign(omega3);\n\n\tmotor_control_pub.publish(out_msg);\n}\n\nSee the following sections below for more details.\n\n\n4: Deriving the Kinematic Equations for a Three-Wheeled Omnidirectional Robot\nAssumptions and Setup\n\nRobot Configuration:\n\nThe robot is a triangle with three holonomic wheels.\nThe wheels are positioned 120 degrees apart from each other.\n\nVariables:\n\n\\(v_x\\): Linear velocity in the x-direction (global frame).\n\\(v_y\\): Linear velocity in the y-direction (global frame).\n\\(\\omega_\\text{body}\\): Rotational velocity of the robot around its center.\n\\(\\theta\\): Orientation of the robot (angle between the robot’s frame and the global frame).\n\\(r\\): Radius of each wheel.\n\\(h\\): Distance from the center of the robot to each wheel.\n\n\nDiagram\n\n\n\nDerivation\nWe aim to derive the angular velocities of the three holonomic wheels \\(\\omega_1\\), \\(\\omega_2\\), \\(\\omega_3\\) based on the robot’s linear veloicities (\\(v_x\\), \\(v_y\\)) and rotational velocity (\\(\\omega_{\\text{body}}\\)) in the global frame, considering the robot’s orientation \\(\\theta\\).\n1. Transform Global Velocities to Local Velocities\nFirst, we need to transform The global velocities \\(v_x\\) and \\(v_y\\) into the local frame of the robot using its orientation \\(\\theta\\):\n\\[\nv_{x,\\text{local}} = v_x \\cos(\\theta) + v_y \\sin(\\theta)\n\\]\n\\[\nv_{y,\\text{local}} = -v_x \\sin(\\theta) + v_y \\cos(\\theta)\n\\]\n2. Express Local Velocities and Rotational Velocity in Terms of Wheel Velocities\nEach wheel contributes to the robot’s motion. The linear velocities of the wheels can be decomposed into components that affect the overall motion of the robot.\nFor a wheel positioned at an angle \\(\\alpha\\) with respect to the robot’s frame: \\[\n\\omega_{\\text{wheel}} = \\frac{1}{r} (v_{x,\\text{local}} \\cos(\\alpha) + v_{y,\\text{local}} \\sin(\\alpha) + \\omega_{\\text{body}} h)\n\\]\nWhere \\(\\omega_\\text{wheel}\\) is the angular velocity of the wheel, and \\(h\\) is the distance from the center to the wheel.\n3. Apply to Each Wheel\nEach wheel is positioned \\(120^\\circ\\) apart, so the angles \\(\\alpha\\) for the three wheels are \\(0^\\circ\\), \\(120^\\circ\\), and \\(240^\\circ\\).\nFor Wheel 1 where \\(\\alpha = 0^\\circ\\):\n\\[\n\\omega_1 = \\frac{1}{r} ( v_{x,\\text{local}} \\cos(0) + v_{y,\\text{local}} \\sin(0) + \\omega_{\\text{body}} h )\n\\]\nSince \\(cos(0^\\circ)= 1\\) and \\(\\sin(0^\\circ) = 0\\):\n\\[\n\\omega_1 = \\frac{1}{r} ( v_{x,\\text{local}} + \\omega_{\\text{body}} h )\n\\]\nSubstituting the local velocities:\n\\[\n\\omega_1 = \\frac{1}{r} ( v_x \\cos(\\theta) + v_y \\sin(\\theta) + \\omega_{\\text{body}} h )\n\\]\nFor Wheel 2 where \\(\\alpha = 120^\\circ\\):\n\\[\n\\omega_2 = \\frac{1}{r} ( v_{x,\\text{local}} \\cos(120^\\circ) + v_{y,\\text{local}} \\sin(120^\\circ) + \\omega_{\\text{body}} h)\n\\]\nSince \\(\\cos(120^\\circ) = -\\frac{1}{2}\\) and \\(\\sin(120^\\circ) = \\frac{\\sqrt{3}}{2}\\):\n\\[\n\\omega_2 = \\frac{1}{r} ( v_{x,\\text{local}}( -\\frac{1}{2} ) + v_{y,\\text{local}} ( \\frac{\\sqrt{3}}{2} ) + \\omega_{\\text{body}} h)\n\\]\n\\[\n\\omega_2 = \\frac{1}{r} ( (v_x \\cos(\\theta) + v_y \\sin(\\theta)) ( -\\frac{1}{2} ) + (-v_x \\sin(\\theta) + v_y \\cos(\\theta)) ( \\frac{\\sqrt{3}}{2} ) + \\omega_{\\text{body}} h )\n\\]\nExpanding and simplifying:\n\\[\n\\omega_2 = \\frac{1}{r} ( -\\frac{1}{2} v_x \\cos(\\theta) - \\frac{1}{2} v_y \\sin(\\theta) + \\frac{\\sqrt{3}}{2} (-v_x \\sin(\\theta)) + \\frac{\\sqrt{3}}{2} v_y \\cos(\\theta) + \\omega_{\\text{body}} h )\n\\]\n\\[\n\\omega_2 = \\frac{1}{r} ( -\\frac{1}{2} v_x \\cos(\\theta) - \\frac{1}{2} v_y \\sin(\\theta) - \\frac{\\sqrt{3}}{2} v_x \\sin(\\theta) + \\frac{\\sqrt{3}}{2} v_y \\cos(\\theta) + \\omega_{\\text{body}} h )\n\\]\nCombining terms and simplifying further:\n\\[\n\\omega_2 = \\frac{1}{r} ( \\frac{\\cos(\\theta) v_y}{3} - \\frac{\\sin(\\theta) v_x}{3} + \\frac{\\sqrt{3} \\sin(\\theta) v_y}{3} + \\frac{\\sqrt{3} \\cos(\\theta) v_x}{3}  + \\omega_{\\text{body}} h )\n\\]\nFor Wheel 3 where \\(\\alpha = 240^\\circ\\):\n\\[\n\\omega_3 = \\frac{1}{r} ( v_{x,\\text{local}} \\cos(240^\\circ) + v_{y,\\text{local}} \\sin(240^\\circ) + \\omega_{\\text{body}} h )\n\\]\nSince \\(\\cos(240^\\circ) = -\\frac{1}{2}\\) and \\(\\sin(240^\\circ) = -\\frac{\\sqrt{3}}{2}\\):\n\\[\n\\omega_3 = \\frac{1}{r} ( (v_x \\cos(\\theta) + v_y \\sin(\\theta)) ( -\\frac{1}{2} ) + (-v_x \\sin(\\theta) + v_y \\cos(\\theta)) ( -\\frac{\\sqrt{3}}{2} ) + \\omega_{\\text{body}} h )\n\\]\nExpanding and simplifying:\n\\[\n\\omega_3 = \\frac{1}{r} ( -\\frac{1}{2} v_x \\cos(\\theta) - \\frac{1}{2} v_y \\sin(\\theta) - \\frac{\\sqrt{3}}{2} (-v_x \\sin(\\theta)) - \\frac{\\sqrt{3}}{2} v_y \\cos(\\theta) + \\omega_{\\text{body}} h )\n\\]\n\\[\n\\omega_3 = \\frac{1}{r} ( -\\frac{1}{2} v_x \\cos(\\theta) - \\frac{1}{2} v_y \\sin(\\theta) + \\frac{\\sqrt{3}}{2} v_x \\sin(\\theta) - \\frac{\\sqrt{3}}{2} v_y \\cos(\\theta) + \\omega_{\\text{body}} h )\n\\]\nCombining terms and simplifying further:\n\\[\n\\omega_3 = \\frac{1}{r} ( -\\frac{\\sqrt{3} \\sin(\\theta) v_y}{3} + \\frac{\\cos(\\theta) v_y}{3} - \\frac{\\sqrt{3} \\cos(\\theta) v_x}{3} - \\frac{\\sin(\\theta) v_x}{3} + \\omega_{\\text{body}} h )\n\\]\n\n\nFinal Equations\nThe final simplified equations for the angular velocities of the wheels are:\n\\[\n\\omega_1 = \\frac{1}{r} ( v_x \\cos(\\theta) + v_y \\sin(\\theta) + \\omega_{\\text{body}} h )\n\\]\n\\[\n\\omega_2 = \\frac{1}{r} ( \\frac{\\cos(\\theta) v_y}{3} - \\frac{\\sin(\\theta) v_x}{3} + \\frac{\\sqrt{3} \\sin(\\theta) v_y}{3} + \\frac{\\sqrt{3} \\cos(\\theta) v_x}{3}  + \\omega_{\\text{body}} h )\n\\]\n\\[\n\\omega_3 = \\frac{1}{r} ( -\\frac{\\sqrt{3} \\sin(\\theta) v_y}{3} + \\frac{\\cos(\\theta) v_y}{3} - \\frac{\\sqrt{3} \\cos(\\theta) v_x}{3} - \\frac{\\sin(\\theta) v_x}{3} + \\omega_{\\text{body}} * h )\n\\]\nThese equations relate the global motion commands (\\(v_x\\), \\(v_y\\), \\(\\omega_{\\text{body}}\\)) to the angular velocities of the three wheels (\\(\\omega_1\\), \\(\\omega_2\\), \\(\\omega_3\\)) taking into account the robot’s orientation \\(\\theta\\), wheel radius \\(r\\) and distance from center to the wheels \\(h\\).\n\n\n5. Converting angular velocities to PWM signal for motor control\nAfter we’ve calculated the angular velocities in terms on radians per second (\\(rad/s\\)), we have to convert to a Pulse Width Modulation (PWM) signal to send updated speed and direction to the motors.\n1. Angular Velocity to RPM\nWe first convert angular velocity (in radians per second) to a revolutions per minute (RPM).\nWe know that \\(1 revolution=2\\pi radians\\) and \\(1 minute = 60 seconds\\), therefore, the conversion factor is:\n\\[\nRPM = \\omega\\times(60/(2\\pi)) \\approx \\omega\\times 9.5493 \\approx \\omega\\times 9.55\n\\]\n2. Conversion from RPM to PWM\nIn order to measure and calibrate the relationship betwen PWM and RPM for the motor, an empirical experiment was performed in order to measurements and fit a linear regression model to the data.\nFor series of PWM signals from a low duty cycle to (eg. 10%) to high duty cycle (eg. 90%) generated using an oscilloscope, the respective RPM for the motor was recorded using a tachometer.\nThe resulting linear relationship is:\n\\[\nPWM = a \\times RPM + b  = 2.4307 \\times RPM + 36.2178\n\\]\nThis means that for every unit increase in RPM, the PWM value increases by approximately 2.4307 units, and when the RPM is zero, the PWM value starts at approximately 36.2178.\n3. Handling Very Small Angular Velocities\nSmall angular velocities &lt;=0.05 are ignored, to smooth the noise and avoid unnecessary motor activation.\n\n\tif(fabs(omega) &lt;= 0.05) return 0;\n\n4. Linear Equation of Angular velocity to PWM\nThrough substituting and simplifying the equations above, we can derive the following linear relationship for converting angular velocity to PWM.\n\\[\nPWM = 2.4307 \\times RPM + 36.2178 =  2.43 \\times (\\omega\\times 9.55) + 36.22\n\\]\nThe result is then returned as an integer PWM value which can be used to control motor speed. We later apply this to each wheel in Big T when calculate the new angular velocities from sensor feedback. We make omega absolute \\(|\\omega_{\\text{wheel}}|\\) in order to ensure the angular velocity is never non-negative.\n\nint\tomega2pwm(float omega) {\n\t/*\n\t\tomega ... angular velocity ( in rad/s )\n\t\trpm = omega*9.5493; // conversion from rad/s to rpm\t ( 1/(2*pi)*60 = 9.5493 )\n\t\tpwm = 2.4307*rpm + 36.2178; // conversion of rpm to pwm values\n\t*/\n\tif(fabs(omega) &lt;= 0.05) return 0;\n\n\treturn (int)(2.43*(fabs(omega)*9.55) + 36.22);\n}\n\n5. Setting Direction Bit of Motor\nThe direction bit of the motor is set based on the sign of the angular velocity \\(\\omega_{\\text{wheel}}\\).\n\nint sign(float number){\n\tif(number&gt;=0) return 1; else return 0;\n}\n\n\nThis project was executed as part of the course - ECEN430: Advanced Mechatronic Engineering 2: Intelligence and Design at Victoria University of Wellington 2018."
  },
  {
    "objectID": "about/index.html",
    "href": "about/index.html",
    "title": "Charlene Leong",
    "section": "",
    "text": "Always endeavouring to understand how AI is transforming our human experience, the technical/non-technical know-how and challenges in effectively bringing R&D to product and client to solve impactful problems.\nContinuously endeavouring to learn in this ever-growing exciting space. Here are some snippets from my journey."
  },
  {
    "objectID": "blog/index.html",
    "href": "blog/index.html",
    "title": "Blog",
    "section": "",
    "text": "Welcome\n\n\n\n\n\n\nnews\n\n\n\n\n\n\n\n\n\nMay 13, 2024\n\n\nCharlene Leong\n\n\n\n\n\n\n\n\n\n\n\n\nKAN\n\n\n\n\n\n\nmodel\n\n\ncode\n\n\nanalysis\n\n\n\n\n\n\n\n\n\nMay 13, 2024\n\n\nCharlene Leong\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "blog/posts/kan/index.html",
    "href": "blog/posts/kan/index.html",
    "title": "KAN",
    "section": "",
    "text": "This is a post with executable code."
  },
  {
    "objectID": "projects/index.html",
    "href": "projects/index.html",
    "title": "Projects",
    "section": "",
    "text": "Order By\n       Default\n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Updated - Oldest\n        \n         \n          Updated - Newest\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\nBig T ROS Navigation and Control\n\n\n10 min\n\n\nAutonomous SLAM and control\n\n\n\nMay 13, 2024\n\n\n\n\n\nMay 18, 2024\n\n\n\n\n\n\n\nNo matching items"
  }
]